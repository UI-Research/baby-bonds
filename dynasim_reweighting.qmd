---
title: "Reweighting of DYNASIM Sample"
format: pdf
execute: 
  echo: false
  warning: false
fig-cap-location: top
toc: true
toc-expand: true
bibliography: references.bib
---

```{r}

library(ipumsr)
library(tidyverse)
library(tidycensus)
library(scales)
library(ggridges)
library(urbnthemes)
set_urbn_defaults(style = "print", 
                  base_size=11,
                  base_line_size = 1
                  )

```

# Introduction

The DYNASIM starting sample contains a nationally representative sample of the population. The sample is constructed with two goals: (1) its distribution of a set of discrete variables like age, sex, race, education must be similar to the distribution of these variables in the population, and (2) the conditional distribution of a continuous variable like earnings or wealth conditional on these discrete variables in the sample must be similar to the one at the population level. The latter is verified by comparing the conditional mean of the continuous variable estimated on the sample with those estimated from nationally representative surveys.

When the area of interest is smaller, such as state or metro area, the DYNASIM sample can be reweighted to resemble the population of interest with respect to a set of individual and household characteristics. Two important choices regarding the weighting process are the choice of reweighting method and the choice of individual and household characteristics—control variables—to be used in reweighting.

There are several reweighting methods but some of them require a sample of the population of interest with the control variables. Because we don't have such a sample, we don't consider the methods that require it. One of the simplest and most commonly used methods is *raking*, which iteratively adjusts the weight for each person until the sample distributions of control variables matches the distributions of the target area. [@mercer2018] evaluated several reweighting methods and found that raking performs as well as more sophisticated methods. Another method proposed by [@schirm2002] uses a *Poisson regression* to predict weights. Control variables are covariates in the regression. Observations are reweighted so that weighted sums of control variables equal targets values.

Regardless of method, control variables need to be selected with care and with consideration to the application. Because both of the above methods work with discrete variables, particularly challenging are applications in which continuous variables are of interest. In our case, it is important that the sample distribution of wealth matches the target distribution. One way to achieve this with the above methods is to use a categorical variable such as quintile or decile of wealth.

Because we are interested not only in its marginal distributions, but also in conditional distributions, we need to interact the control variables.

# ACS Microdata Estimates

This section shows estimates of income and homeownership rates for Boston, New York City, and Oakland based on the 5-year American Community Survey (2019). Included in the sample are adults ages 25 to 70 who identify as Black, Hispanic, or white. All estimates are done at the individual level using individual weights. The smallest cell in the sample has 28 observations for Hispanic women ages 55 to 70 with some college who live in Oakland.

```{r}


city_codes = list(
    "Boston"    = 810,
    "New York"  = 4610,    
    "Oakland"   = 4930
)

setwd(paste0(here::here(), "/ACS"))
source("usa_00013.R")
setwd(here::here())

acsdf = data |>
    mutate(
        educ = case_when(
            EDUC<=6 ~ "High School or Less",
            EDUC<=9 ~ "Some College",
            TRUE    ~ "College Diploma"
        ),
        race = case_when(
            HISPAN %in% 1:4 ~ "Hispanic",
            RACE == 1 ~ "White",
            RACE == 2 ~ "Black",
            TRUE ~ "Other"
        ),
        city = case_when(
            CITY ==  810 ~ "Boston",
            CITY == 4610 ~ "New York",
            CITY == 4930 ~ "Oakland",
            TRUE ~ "Other"
        ),
        age_cat = case_when(
            25<=AGE & AGE<=39   ~ "25-39",
            40<=AGE & AGE<=54   ~ "40-54",
            55<=AGE & AGE<=70   ~ "55-70",
            TRUE                ~ "Other"
        ),
        sex = case_when(
            SEX==1 ~ "Male",
            SEX==2 ~ "Female",
            TRUE   ~ "Other"
        )
    ) |>
    filter(
        race != "Other", 
        city != "Other",
        age_cat != "Other",
        sex != "Other"
    )

# Total individual income
incdf = acsdf |>
    filter(INCTOT < 9999999) |>
    group_by(age_cat, sex, educ, race, city) |>
    summarise(
        inctot = weighted.mean(INCTOT, PERWT),
        inctot_p25 =  Hmisc::wtd.quantile(INCTOT, PERWT, probs=.25),
        inctot_p50 =  Hmisc::wtd.quantile(INCTOT, PERWT, probs=.5),
        inctot_p75 =  Hmisc::wtd.quantile(INCTOT, PERWT, probs=.75),
        n = n(),
        pop = sum(PERWT)
    ) |>
    mutate(
        educ = factor(educ, levels=c("High School or Less", "Some College", "College Diploma"))
    )


# Total individual income
howndf = acsdf |>
    filter(OWNERSHP > 0) |>
    group_by(age_cat, sex, educ, race, city) |>
    mutate(homeown = as.integer(OWNERSHP==1)) |>
    summarise(
        homeown = weighted.mean(homeown, PERWT),
        n = n(),
        pop = sum(PERWT)
    ) |>
    mutate(
        educ = factor(educ, levels=c("High School or Less", "Some College", "College Diploma"))
    )

plot_city_inc = function(sexarg, var)
{
    return(
    incdf |> 
        filter(sex==sexarg) |>
        ggplot() +
        geom_col(aes(x=age_cat, y={{var}}, fill=city), position="dodge") +
        scale_y_continuous(labels=\(x) x/1000) +
        facet_grid(rows=vars(race), cols=vars(educ)) +
        xlab("Age") + ylab("Income (thousands)")
    )
}


plot_city_inc2 = function(sexarg, agearg)
{
    return(
    incdf |> 
        filter(sex==sexarg & age_cat==agearg) |>
        select(starts_with("inctot"), race, educ, city) |> 
        pivot_longer(starts_with("inctot_"), names_prefix="inctot_", names_to="Percentile", values_to="Income") |>
        ggplot() +
        geom_line(aes(x=Percentile, y=Income, color=city, group=city)) +
        scale_y_continuous(labels=\(x) x/1000) +
        facet_grid(rows=vars(race), cols=vars(educ)) +
        xlab("Percentiles") + ylab("Income (thousands)")
    )
}

plot_city_homeown = function(sexarg)
{
    return(
    howndf |> 
        filter(sex==sexarg) |>
        ggplot() +
        geom_col(aes(x=age_cat, y=homeown, fill=city), position="dodge") +
        facet_grid(rows=vars(race), cols=vars(educ)) +
        xlab("Age") + ylab("Homeownership")
    )
}


```

## Women

### Mean Income

```{r}
#| results: asis

plot_city_inc("Female", inctot)

```

### Percentiles of Income

```{r}
#| results: asis



agecats = c("25-39","40-54","55-70")
plots = map(agecats, \(x) plot_city_inc2("Female", x))

pwalk(list(agecats, plots), ~{
    cat("#### Ages ", .x, '\n\n')
    print(.y)
    cat('\n\n')
})


```

### Homeownership Rates

```{r}
#| results: asis

plot_city_homeown("Female")

```

## Men

### Mean Income

```{r}
#| results: asis

plot_city_inc("Female", inctot)

```

### Percentiles of Income

```{r}
#| results: asis


agecats = c("25-39","40-54","55-70")
plots = map(agecats, \(x) plot_city_inc2("Female", x))

pwalk(list(agecats, plots), ~{
    cat("#### Ages ", .x, '\n\n')
    print(.y)
    cat('\n\n')
})


```

### Homeownership Rates

```{r}
#| results: asis

plot_city_homeown("Male")

```

# ACS Tables

## Age-Sex-Race Tables

```{r}
#| label: get-acs-tables-data

#census_api_key(censuskey, install = TRUE)

acs_data_dir        = paste0(here::here(), "/ACS/")
acs1_asr_filename   = paste0(acs_data_dir, "acs2022_asr.rds")
acs1_pov_filename   = paste0(acs_data_dir, "acs2022_pov.rds")


places = tribble(
  ~state,   ~geoid,       ~city,
  "CA",     "0653000",    "Oakland",
  "GA",     "1304000",    "Atlanta",
  "MA",     "2507000",    "Boston",
  "MD",     "2404000",    "Baltimore"
)

acs1vars = load_variables(2022, "acs1", cache=TRUE)

#
# Returns specified ACS tables for the specified state and GEOID
# 
get_acs_tables = function(tables, state, geoid)
{

    get_one_acs_table = function(table, state, geoid)
    {
        return(
            get_acs(
                geography = "place", 
                table = table,
                survey="acs1",
                state=state,
                year = 2022
            ) |>
            filter(GEOID==geoid)
        )
    }
  
    return(list_rbind(
        map(tables, 
            \(t) get_one_acs_table(
                table = t,
                state=state,
                geoid=geoid
                )
            )
        )
    )
}

#
# Returns specified ACS tables for the specified places
# 
get_acs_tables_for_places = function(places, tabcodes)
{
    return(
        list_rbind(
            apply(
                places, 
                1, 
                \(x) get_acs_tables(tabcodes, x['state'], x['geoid'])
            )
        )
    )
}

get_acs_b01001_agecats = function()
{
    return(
        agecatsdf = tribble(
          ~longage,           ~shortage,
          "Under 5 years",      "<5",
          "5 to 9 years",       "5-9",
          "10 to 14 years",     "10-14",
          "15 to 17 years",     "15-17",
          "18 and 19 years",    "18-19",
          "20 to 24 years",     "20-24",
          "25 to 29 years",     "25-29",
          "30 to 34 years",     "30-34",
          "35 to 44 years",     "35-44",
          "45 to 54 years",     "45-54",
          "55 to 64 years",     "55-64",
          "65 to 74 years",     "65-74",
          "75 to 84 years",     "75-84",
          "85 years and over",  "85+",
          "All",                 "All"
        )
    )  
}

get_acs_by_sex_age_race = function()
{
    # Tables we need
    acs1tabs = tribble(
        ~code,      ~concept,
#        "B01001A",  "Sex by Age (White Alone)",
        "B01001B",  "Sex by Age (Black or African American Alone)",
        "B01001C",  "Sex by Age (American Indian and Alaska Native Alone)", 
        "B01001D",  "Sex by Age (Asian Alone)", 
        "B01001E",  "Sex by Age (Native Hawaiian and Other Pacific Islander Alone)",
        "B01001F",  "Sex by Age (Some Other Race Alone)",
        "B01001G",  "Sex by Age (Two or More Races)",
        "B01001H",  "Sex by Age (White Alone, Not Hispanic or Latino)",
        "B01001I",  "Sex by Age (Hispanic or Latino)"
    )
    
    # Age categories in these tables
    agecatsdf = get_acs_b01001_agecats()
    
    #        
    # Fetch the tables
    b01001fname = paste0(here::here(), "/ACS/B01001.rds")
    if( file.exists(b01001fname) ) {
        datadf = readRDS(b01001fname)
    } else {
        datadf = get_acs_tables_for_places(places, acs1tabs$code)
        saveRDS(datadf, b01001fname)
    }
    
    # Create labels
    labdf = list_rbind(
        #
        # Filter only variables from the tables we use
        map(acs1tabs$code, \(x) filter(acs1vars, grepl(paste0("^",x,"_"), name)))
        ) |>
        #
        # Use "All" for totals
        mutate(
            label=str_replace(label,"^Estimate!!Total:!*", ""),
            label=case_when(
                label=="" ~ "All:!!All",
                label=="Male:" ~ "Male:!!All",
                label=="Female:" ~ "Female:!!All",
                TRUE ~ label
            ),
            race=gsub("Sex by Age \\((.+)\\)", "\\1", concept),
            race=gsub(" Alone", "", race),
            race=gsub(" or African American", "", race),
            race=if_else(race=="Hispanic or Latino", "Hispanic", race),
            race=if_else(race=="White, Not Hispanic or Latino", "White", race),
            race=if_else(
              race %in% c("Asian", "Black", "White", "Hispanic"), 
              race, 
              "Other")
            
        ) |>
        #
        # Create columns "sex" and "agecat"
        separate_wider_regex(
            label, 
            c(
                sex="All|Male|Female", 
                ":!!", 
                agecat=".+"
            )
        ) |>
        #
        # Convert agecat to a factor
        mutate(
            agecat=factor(agecat, 
                          levels=agecatsdf$longage, 
                          labels=agecatsdf$shortage)
            ) |>
        #
        # Rename "name", we will use it for a join
        rename(variable=name)
    
    resdf = left_join(
        datadf,
        labdf,
        by="variable"
    )
    
    return(resdf)
}

get_acs_b17024_agecats = function()
{
    return(
        tribble(
        ~longage,            ~shortage,
        "Under 6 years",     "<6",
        "6 to 11 years",     "6-11",
        "12 to 17 years",    "12-17",
        "18 to 24 years",    "18-24",
        "25 to 34 years",    "25-34",
        "35 to 44 years",    "35-44",
        "45 to 54 years",    "45-54",
        "55 to 64 years",    "55-64",
        "65 to 74 years",    "65-74",
        "75 years and over", "75+",
        "All",               "All"
        )
    )
}  

get_acs_b17024_inccats = function()
{
    return(
        tribble(
            ~longinc,         ~shortinc,
            "Under .50",      "<0.50",
            ".50 to .74",     "0.50-0.74",
            ".75 to .99",     "0.75-0.99",
            "1.00 to 1.24",   "1.00-1.24",
            "1.25 to 1.49",   "1.25-1.49",
            "1.50 to 1.74",   "1.50-1.74",
            "1.75 to 1.84",   "1.75-1.84",
            "1.85 to 1.99",   "1.85-1.99",
            "2.00 to 2.99",   "2.00-2.99",
            "3.00 to 3.99",   "3.00-3.99",
            "4.00 to 4.99",   "4.00-4.99",
            "5.00 and over",  "5.00+",
            "All",            "All"
        )
    )
}

get_acs_poverty_age = function()
{
    # Tables we need
    acs1tabs = tribble(
        ~code,      ~concept,
        "B17024",   "Age by Ratio of Income to Poverty Level in the Past 12 Months"
    )
    
    agecatsdf = get_acs_b17024_agecats()

    inccatsdf = get_acs_b17024_inccats()
    #        
    # Fetch the tables
    b17024fname = paste0(here::here(), "/ACS/B17024.rds")
    if( file.exists(b17024fname) ) {
        datadf = readRDS(b17024fname)
    } else {
        datadf = get_acs_tables_for_places(places, acs1tabs$code)
        saveRDS(datadf, b17024fname)
    }
    #
    # Create labels
    labdf = list_rbind(
        #
        # Filter only variables from the tables we use
        map(acs1tabs$code, \(x) filter(acs1vars, grepl(paste0("^",x,"_"), name)))
        ) |>
        #
        # Use "All" for totals
        mutate(
            label=str_replace(label,"^Estimate!!Total:!*", ""),
            label=if_else(label=="", "All:!!All", label),
            label = if_else(!grepl("!", label), paste0(label,"!!All"), label)
            ) |>
        #
        # Create columns "sex" and "agecat"
        separate_wider_regex(
            label, 
            c(
                agecat="All|.+years|.+over", 
                ":!!", 
                inc_pov_r=".+"
            ),
#            too_few = "debug"
        ) |>
        #
        # Convert agecat to a factor
        mutate(
            agecat    =factor(agecat, 
                              levels=agecatsdf$longage, 
                              labels=agecatsdf$shortage),
            inc_pov_r = factor(inc_pov_r,
                              levels=inccatsdf$longinc, 
                              labels=inccatsdf$shortinc)
            ) |>
        #
        # Rename "name", we will use it for a join
        rename(variable=name)
    
    resdf = left_join(
        datadf,
        labdf,
        by="variable"
    )
    
    return(resdf)
}



if( file.exists(acs1_asr_filename) ) {
    asrdf = readRDS(acs1_asr_filename)   
} else {
    asrdf = get_acs_by_sex_age_race()
    saveRDS(asrdf, acs1_asr_filename)
}

if( file.exists(acs1_pov_filename) ) {
    povdf = readRDS(acs1_pov_filename)   
} else {
    povdf = get_acs_poverty_age()
    saveRDS(povdf, acs1_pov_filename)
}


```

```{r}
#| label: fig-city-population-by-race
#| fig-cap: "Population of each city by race"
#| fig-subcap: 
#|  - "All ages"
#|  - "Children younger than five"

plotdf = asrdf |> group_by(GEOID,sex,agecat,race) |>
  summarise(population=sum(estimate, na.rm = TRUE)) |>
  ungroup() |>
  rename(geoid=GEOID) |>
  left_join(places, by="geoid") |>
  filter(sex=="All" & agecat=="All") |>
  arrange(city, desc(race)) |>
  group_by(city) |>
  mutate(pos=cumsum(population)-population/2)

plotdf |>
  ggplot() +
  geom_col(aes(x=city, y=population, fill=race)) +
  scale_y_continuous(labels=\(x) x/1000) +
  ylab("Population (1000s)") +xlab("City") +
  geom_text(aes(x=city, y=pos, label=as.integer(population/1000)),color="white", size=3)


plotdf = asrdf |> group_by(GEOID,sex,agecat,race) |>
  summarise(population=sum(estimate, na.rm = TRUE)) |>
  ungroup() |>
  rename(geoid=GEOID) |>
  filter(agecat=="<5") |> 
  group_by(geoid,race) |>
  summarise(population=sum(population, na.rm = TRUE)) |>
  ungroup() |>
  left_join(places, by="geoid") |>
  arrange(city, desc(race)) |>
  group_by(city) |>
  mutate(pos=cumsum(population)-population/2)

plotdf |>
  ggplot() +
  geom_col(aes(x=city, y=population, fill=race)) +
  scale_y_continuous(labels=\(x) x/1000) +
  ylab("Population (1000s)") + xlab("City") +
  geom_text(aes(x=city, y=pos, label=round(population/1000,1)),color="white", size=3)

```


```{r}
#| label: fig-city-population-by-race-age
#| fig-cap: "Population of each city by race and age group"

plotdf = asrdf |> 
  filter(sex!="All",agecat!="All") |>
  group_by(GEOID,agecat,race) |>
  summarise(population=sum(estimate, na.rm = TRUE)) |>
  ungroup() |>
  rename(geoid=GEOID) |>
  left_join(places, by="geoid")

plotdf |>
  ggplot() +
  geom_col(aes(x=agecat, y=population, fill=race)) +
  facet_wrap(~city) +
  scale_y_continuous(labels=\(x) x/1000) +
  ylab("Population (1000s)") +xlab("City") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))


```

```{r}
#| label: fig-inc-to-pov-by-age
#| fig-cap: "The ratio of household income to poverty level by age"

plotdf = povdf |> group_by(GEOID,agecat,inc_pov_r) |>
  summarise(population=sum(estimate, na.rm = TRUE)) |>
  ungroup() |>
  rename(geoid=GEOID) |>
  filter(agecat=="<6", inc_pov_r!="All") |> 
  group_by(geoid,inc_pov_r) |>
  summarise(population=sum(population, na.rm = TRUE)) |>
  ungroup() |>
  left_join(places, by="geoid")

plotdf |>
  ggplot() +
  geom_col(aes(x=inc_pov_r, y=population)) +
  facet_wrap(~city) +
  ylab("Population") +xlab("Income-to-poverty-level ratio") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))



```

# Raking

```{r}
#| label: raking-functions    


make_sex_race_target = function(geoid)
{
    df = asrdf |> 
        filter(
            sex!="All",
            agecat=="<5",
            GEOID==geoid) |>
        mutate(
            race = if_else(race %in% c("Black","Hispanic","White"), race, "Other")
        ) |>
        mutate(
            sexrace := paste0(sex, "-", race)
        ) |>
        group_by(sexrace) |>
        summarise(target=sum(estimate, na.rm = TRUE))
    return(df)
}

make_income_target = function(geoid)
{
    df = povdf |> 
        filter(
            inc_pov_r!="All", 
            agecat=="<6",
            GEOID==geoid) |>
        select(target=estimate, inc_pov_r)
    return(df)
}

encode_dyn_race_sex = function(data)
{
    return(
    data |> 
      mutate(
        raceeth = case_when(
             raceeth==1 ~ "Black",
             raceeth==2 ~ "Hispanic",
             raceeth==3 ~ "White",
             TRUE ~ "Other"
         ),
        sex = if_else(male==0, "Female", "Male"),
        sexrace = paste0(sex, "-", raceeth)
      )
    )
}

encode_dyn_inc_pov_r = function(data, invar, outvar)
{
  incintdf = get_acs_b17024_inccats() |> 
    filter(shortinc!="All") |> 
    mutate(shortinc2=shortinc) |>
    separate_wider_regex(shortinc2, c(low=".*", "\\<|\\-|\\+", high=".*")) |>
    mutate(
      across(c(low,high), as.numeric),
      low = if_else(shortinc=="<0.50", -1, low)
    )

  df = data |>
    mutate(
      {{outvar}} := cut(
          {{invar}}, 
          c(incintdf$low, Inf), 
          labels=incintdf$shortinc, 
          right=FALSE
          )
    )
  
  return(df)
}

make_multipliers = function(data, varname, targetdf)
{
    var = rlang::sym(varname)
    
    have = data |> group_by({{var}}) |> summarise(have=sum(weight))

    # Create multiplier dataframe
    mpdf = left_join(
            have,
            targetdf,
            by=varname
        ) |>
        mutate(mplier = if_else(have==0 & target==0, 1, target/have)) |>
        select({{var}}, mplier)
    return(mpdf)
}

apply_multipliers = function(data, mpdf, varname)
{
    var = rlang::sym(varname)

    df = left_join(
        data,
        mpdf,
        by=varname
    ) |>
        mutate(weight = weight*mplier) |>
        select(-mplier)
    return(df)
    
}

reweight_by = function(data, varname, targetdf)
{
    mpdf = data |> make_multipliers(varname, targetdf)
    df   = data |> apply_multipliers(mpdf, varname)
    return(df)
}

calculate_diff = function(data, varname, targetdf)
{
    return(
        data |> 
            make_multipliers(varname, targetdf) |>
            mutate(diff=abs(1-mplier)) |>
            summarise(diff=max(diff)) |>
            pull()
    )
}


```

```{r}
#| label: raking-procedure

rake_to_place = function(geoid, tol=.0001, maxiter=10)
{

    print(paste0("Starting the raking procedure for geoid = ", geoid))
    
    # Create targets
    targets=list(
        inc_pov_r   = make_income_target(geoid),
        sexrace     = make_sex_race_target(geoid)
    )
    
    targ_tot = map(targets, \(x) summarize(x, target=sum(target)))
    for(i in 2:length(targets)) {
        adj = pull(targ_tot[[1]] / targ_tot[[i]])
        targets[[i]] = mutate(targets[[i]], target=target*adj)
    }
    targ_tot2 = map(targets, \(x) summarize(x, target=sum(target)))
    
    
    # Create the micro data
    df0 = read_csv("X:/programs/Run1006(babybonds)/BabyBonds/BabyBondsData14AUG24.csv", show_col_types=FALSE) |>
        rename_all(tolower) |>
        filter(age==18) |>
        encode_dyn_race_sex() |>  
        encode_dyn_inc_pov_r(lhinc, inc_pov_r) |>
        select(pernum, weight, sexrace, inc_pov_r) |>
        mutate(weight=weight*1000)
    
    df=df0
    
    converged=FALSE
    for(i in 1:maxiter) {
    
        for(k in 1:length(targets)) 
        {
            df = df |> reweight_by(names(targets)[k], targets[[k]])
        }
        
        diffs = c()
        for(k in 1:length(targets)) 
        {
            varname = names(targets)[k]
            diffs[varname] =  df |> calculate_diff(varname, targets[[k]])
        }
        
        maxdiff = max(diffs)
        
        print(paste0("Iteration ", i, " diff: ", paste(names(diffs), diffs, sep=":", collapse=",")))
              
        if(maxdiff < tol) {
            converged=TRUE
            print(paste0("Convergence achieved in ", i, " iterations with maxdiff = ", maxdiff))
            break
        }
    }
    
    if( ! converged ) {
        print("No convergence")
    }
    return(df)
}

res = map(places$geoid, rake_to_place)

```



# Bibliography

::: {#refs}
:::
